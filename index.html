<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MicroHOA Water Billing Allocator</title>
  <meta name="description" content="Penny-perfect water/sewer allocation for small associations" />
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24'%3E%3Cpath fill='%23098' d='M12 2c3.5 4.7 7 8.38 7 12a7 7 0 1 1-14 0c0-3.62 3.5-7.3 7-12z'/%3E%3C/svg%3E" />
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    :root { color-scheme: light; }
    .card { border:1px solid #e4e4e7; border-radius:24px; background:#fff; padding:20px; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    .btn { display:inline-flex; align-items:center; gap:8px; border-radius:16px; padding:8px 16px; font-size:14px; font-weight:600; transition:background .2s ease, box-shadow .2s ease; cursor:pointer; }
    .btn-primary { background:#0f766e; color:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.06); }
    .btn-primary:hover { background:#115e59; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .input, .select { width:100%; border:1px solid #d4d4d8; border-radius:16px; padding:8px 12px; background:#fff; color:#18181b; box-shadow:0 1px 2px rgba(0,0,0,0.04); }
    .input:focus, .select:focus { outline:none; box-shadow:0 0 0 2px #14b8a6; }
    .label { display:block; font-size:14px; font-weight:500; color:#3f3f46; }
    .help { font-size:12px; color:#71717a; }
  </style>
</head>
<body class="min-h-screen w-full bg-gradient-to-b from-teal-50 to-white text-zinc-900">
  <div class="mx-auto max-w-5xl px-4 py-10">
    <header class="mb-6 flex items-center justify-between">
      <div class="flex items-center gap-3">
        <div class="flex h-10 w-10 items-center justify-center rounded-2xl bg-teal-600 text-white shadow">
          <svg viewBox="0 0 24 24" class="h-6 w-6" aria-hidden>
            <path fill="currentColor" d="M12 2c3.5 4.7 7 8.38 7 12a7 7 0 1 1-14 0c0-3.62 3.5-7.3 7-12z"/>
          </svg>
        </div>
        <div>
          <h1 class="text-3xl font-semibold tracking-tight">MicroHOA Water Billing Allocator</h1>
          <p class="text-sm text-zinc-500">Penny-perfect allocations for small associations</p>
        </div>
      </div>
      <span class="hidden rounded-2xl border border-teal-200 bg-white px-3 py-2 text-sm font-medium text-teal-700 shadow-sm md:inline-flex">MicroHOA</span>
    </header>

    <div class="card mb-6">
      <div class="grid grid-cols-1 gap-5 md:grid-cols-2">
        <div>
          <label class="label">HOA</label>
          <select id="hoa" class="select">
            <option>Sherman Townhomes</option>
          </select>
          <p class="help mt-1">More HOAs can be added later.</p>
        </div>
        <div>
          <label for="chargeName" class="label">Import Charge Name</label>
          <input id="chargeName" class="input" placeholder="Water Billing" />
          <p class="help mt-1">Remembered between sessions. Used for the Import sheet.</p>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="grid grid-cols-1 gap-6 md:grid-cols-3">
        <div>
          <label for="bill" class="label">Bill PDF</label>
          <input id="bill" type="file" accept="application/pdf" class="input" />
          <p class="help mt-1">Utility bill (PDF). I'll parse dates & category totals.</p>
        </div>
        <div>
          <label for="usage" class="label">Usage CSV</label>
          <input id="usage" type="file" accept=".csv,text/csv" class="input" />
          <p class="help mt-1">Columns needed: <em>Unit</em>, <em>Meter Usage</em> (blanks=0).</p>
        </div>
        <div>
          <label for="owner" class="label">Owner Export (Account Map)</label>
          <input id="owner" type="file" accept=".csv,text/csv" class="input" />
          <p class="help mt-1">Only <em>Unit</em> and <em>Account</em> are used. Address may be used to extract unit #.</p>
        </div>
      </div>

      <div class="mt-8 grid grid-cols-1 gap-4 md:grid-cols-4">
        <div>
          <label class="label" for="fix-billingStart">Billing Start</label>
          <input id="fix-billingStart" type="date" class="input" />
        </div>
        <div>
          <label class="label" for="fix-billingEnd">Billing End</label>
          <input id="fix-billingEnd" type="date" class="input" />
        </div>
        <div>
          <label class="label" for="fix-billDate">Bill Date</label>
          <input id="fix-billDate" type="date" class="input" />
        </div>
        <div>
          <label class="label" for="fix-dueDate">Due Date</label>
          <input id="fix-dueDate" type="date" class="input" />
        </div>
      </div>

      <div class="mt-6 grid grid-cols-1 gap-4 md:grid-cols-5">
        <div>
          <label class="label" for="fix-water">Water ($)</label>
          <input id="fix-water" type="number" step="0.01" placeholder="0.00" class="input" />
        </div>
        <div>
          <label class="label" for="fix-sewer">Sewer ($)</label>
          <input id="fix-sewer" type="number" step="0.01" placeholder="0.00" class="input" />
        </div>
        <div>
          <label class="label" for="fix-stormwater">Stormwater ($)</label>
          <input id="fix-stormwater" type="number" step="0.01" placeholder="0.00" class="input" />
        </div>
        <div>
          <label class="label" for="fix-base">Base ($)</label>
          <input id="fix-base" type="number" step="0.01" placeholder="0.00" class="input" />
        </div>
        <div>
          <label class="label" for="fix-superfund">Portland Harbor Superfund ($)</label>
          <input id="fix-superfund" type="number" step="0.01" placeholder="0.00" class="input" />
        </div>
      </div>

      <div class="mt-8 flex items-center gap-3">
        <button id="process" class="btn btn-primary">
          <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M3 12h18M12 3v18"/></svg>
          Process & Generate
        </button>
        <p id="msg" class="help"></p>
      </div>

      <div id="downloads" class="mt-6 grid grid-cols-1 gap-3 sm:grid-cols-3"></div>
    </div>

    <div class="mt-8 text-xs text-zinc-500">
      <p><strong>How it works:</strong> I parse the bill PDF for dates &amp; category totals; read usage &amp; owner CSVs; allocate costs (usage proportional for Water/Sewer; equal split for Stormwater/Base/Superfund) with penny-perfect reconciliation (usage cats distribute remaining cents by highest usage first; flat by unit order). Then I export a full workbook and "Import-only" files.</p>
    </div>

    <footer class="mt-12 border-t border-zinc-200 py-6 text-xs text-zinc-500">
      <div class="flex flex-col items-start justify-between gap-3 sm:flex-row sm:items-center">
        <span>© <span id="year"></span> MicroHOA — Water Billing Allocator</span>
        <span class="text-zinc-400">Built for Sherman Townhomes (more HOAs coming soon)</span>
      </div>
    </footer>
  </div>

  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@2.16.105/build/pdf.worker.min.js';

    const $ = (id) => document.getElementById(id);
    const msg = $("msg");
    const downloads = $("downloads");
    const chargeNameInput = $("chargeName");
    chargeNameInput.value = localStorage.getItem("mh_charge_name") || "Water Billing";
    $("year").textContent = new Date().getFullYear();

    const parseUsDate = (s) => {
      const m1 = s.match(/\b(\d{1,2})\/(\d{1,2})\/(\d{2,4})\b/);
      if (m1) {
        const y = Number(m1[3].length === 2 ? (Number(m1[3]) + 2000) : m1[3]);
        const d = Number(m1[2]);
        const mo = Number(m1[1]) - 1;
        const dt = new Date(y, mo, d);
        return isNaN(dt.getTime()) ? undefined : dt;
      }
      const m2 = s.match(/\b(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)[a-z]*\s+\d{1,2},\s*\d{4}\b/i);
      if (m2) return new Date(m2[0]);
      return undefined;
    };

    const toStartOfNextMonth = (d) => {
      const base = d || new Date();
      return new Date(base.getFullYear(), base.getMonth() + 1, 1);
    };

    const fileToArrayBuffer = (f) => new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.onerror = rej;
      r.readAsArrayBuffer(f);
    });

    const fileToText = (f) => new Promise((res, rej) => {
      const r = new FileReader();
      r.onload = () => res(r.result);
      r.onerror = rej;
      r.readAsText(f);
    });

    const byNumericUnitOrder = (a, b) => {
      const na = Number(String(a).replace(/\D/g, ""));
      const nb = Number(String(b).replace(/\D/g, ""));
      if (!isNaN(na) && !isNaN(nb)) return na - nb;
      return String(a).localeCompare(String(b));
    };
    const streetNumber = (addr) => {
      if (!addr) return;
      const m = String(addr).match(/\b(\d{1,6})\b/);
      return m ? m[1] : undefined;
    };

    // === FIX 1: money parser returns undefined when a label isn't found (not 0) ===
    const moneyFromTextAfterLabel = (t, label) => {
      const m = t.match(new RegExp(label.source + `[":\s-]*\$?\s*([\n\r\t\s$,\d.-]+)`, "i"));
      if (!m) return undefined; // important: differentiate missing vs 0
      const n = Number(String(m[1]).replace(/[^\d.-]/g, ""));
      return isFinite(n) ? n : undefined;
    };

    async function parseBillPDF(file) {
      try {
        const ab = await fileToArrayBuffer(file);
        const loadingTask = pdfjsLib.getDocument(ab);
        const doc = await loadingTask.promise;

        let text = "";
        for (let p = 1; p <= doc.numPages; p++) {
          const page = await doc.getPage(p);
          const content = await page.getTextContent();
          text += "\n" + content.items.map((it) => it.str || "").join("\n");
        }
        const t = text.replace(/\u00A0/g, " ");

        // Pull values (possibly undefined if not found)
        const water = moneyFromTextAfterLabel(t, /\bWater\b/);
        const sewer = moneyFromTextAfterLabel(t, /\bSewer\b/);
        const storm1 = moneyFromTextAfterLabel(t, /Stormwater\s*(?:Total)?/);
        const billableArea = moneyFromTextAfterLabel(t, /Billable\s*Area/);
        const serviceUnit = moneyFromTextAfterLabel(t, /Service\s*Unit/);
        const stormwater = (storm1 ?? 0) || ((billableArea ?? 0) + (serviceUnit ?? 0)) || undefined;
        const base = moneyFromTextAfterLabel(t, /Base(\s*Charge)?/);
        const superfund = moneyFromTextAfterLabel(t, /Portland\s*Harbor\s*Superfund/);

        const dateAfter = (label) => {
          const m = t.match(new RegExp(label.source + `[\"\\s:]*([^\n\r]+)`, "i"));
          return m ? parseUsDate(m[1].trim()) : undefined;
        };
        const billingStart = dateAfter(/Billing\s*Start/);
        const billingEnd = dateAfter(/Billing\s*End/);
        const billDate = dateAfter(/Bill\s*Date/);
        const dueDate = dateAfter(/Due\s*Date/);

        return {
          billingStart,
          billingEnd,
          billDate,
          dueDate,
          totals: { water, sewer, stormwater, base, superfund },
          rawText: t,
        };
      } catch (error) {
        console.error('PDF parsing error:', error);
        throw new Error('Failed to parse PDF. Please check the file and try again.');
      }
    }

    function parseUsageCSV(text) {
      const { data, meta } = Papa.parse(text, { header: true, skipEmptyLines: true });
      const rows = data;
      const headers = (meta.fields || []).map((h) => String(h || ""));
      const unitCol =
        headers.find((h) => /^(unit|unit_no|unit number|unit#)$/i.test(h)) ||
        headers.find((h) => /unit/i.test(h)) ||
        headers[0];
      const usageCol =
        headers.find((h) => /^(meter\s*usage|usage|consumption|ccf|gallons)$/i.test(h)) ||
        headers.find((h) => /usage|consumption|ccf|gallon/i.test(h)) ||
        headers[1];
      return rows
        .map((r) => ({
          unit: String(r[unitCol] ?? "").trim(),
          usage:
            String(r[usageCol] ?? "").trim() === ""
              ? 0
              : Number(String(r[usageCol]).replace(/[^\d.\-]/g, "")) || 0,
        }))
        .filter((r) => r.unit !== "");
    }

    function parseOwnerExport(text) {
      const { data, meta } = Papa.parse(text, { header: true, skipEmptyLines: true });
      const rows = data;
      const headers = (meta.fields || []).map((h) => String(h || ""));
      const unitCol =
        headers.find((h) => /^(unit|unit_no|unit number|unit#)$/i.test(h)) ||
        headers.find((h) => /unit/i.test(h));
      const accountCol =
        headers.find((h) => /^account$/i.test(h)) || headers.find((h) => /account/i.test(h));
      const addressCol =
        headers.find((h) => /^address$/i.test(h)) || headers.find((h) => /address/i.test(h));
      return rows.map((r) => ({
        unit: r[unitCol] ? String(r[unitCol]).trim() : undefined,
        account: r[accountCol] ? String(r[accountCol]).trim() : undefined,
        address: r[addressCol] ? String(r[addressCol]).trim() : undefined,
      }));
    }

    function allocate(bill, usageRows, ownerRows) {
      const normUnit = (u) => {
        const n = String(u).match(/\d+/)?.[0];
        return n ? n : String(u).trim();
      };
      const unitsSet = new Set();
      usageRows.forEach((r) => unitsSet.add(normUnit(r.unit)));
      const unitToAccount = new Map();
      ownerRows.forEach((row) => {
        const u = row.unit
          ? normUnit(row.unit)
          : streetNumber(row.address) ?? undefined;
        if (!u) return;
        if (row.account) unitToAccount.set(u, row.account);
      });
      const units = Array.from(unitsSet).sort(byNumericUnitOrder);
      const usageByUnit = new Map();
      usageRows.forEach(({ unit, usage }) => {
        const key = normUnit(unit);
        usageByUnit.set(key, (usageByUnit.get(key) || 0) + (isFinite(usage) ? usage : 0));
      });
      const totalUsage = Array.from(usageByUnit.values()).reduce((a, b) => a + b, 0);
      const nUnits = units.length || 1;

      // Work strictly in cents for penny perfection
      const cents = (n) => Math.round((Number(n) || 0) * 100);
      const fromCents = (c) => Number((c / 100).toFixed(2));

      const categories = [
        { key: "water", type: "usage", label: "Water" },
        { key: "sewer", type: "usage", label: "Sewer" },
        { key: "stormwater", type: "flat", label: "Stormwater" },
        { key: "base", type: "flat", label: "Base Charge" },
        { key: "superfund", type: "flat", label: "Portland Harbor Superfund" },
      ];

      const perUnit = {};
      units.forEach((u) => {
        perUnit[u] = {
          unit: u,
          usage: usageByUnit.get(u) || 0,
          Water: 0,
          Sewer: 0,
          Stormwater: 0,
          "Base Charge": 0,
          "Portland Harbor Superfund": 0,
        };
      });

      categories.forEach((cat) => {
        const total = bill.totals[cat.key] ?? 0; // treat missing as 0 for math
        const totalC = cents(total);
        if (totalC === 0) return;

        if (cat.type === "usage") {
          if (totalUsage === 0) {
            // no usage -> equal split
            const baseC = Math.floor(totalC / nUnits);
            let remainder = totalC - baseC * nUnits;
            units.forEach((u, i) => {
              const add = i < remainder ? 1 : 0;
              perUnit[u][cat.label] += baseC + add;
            });
          } else {
            const prelim = units.map((u) => {
              const uUsage = usageByUnit.get(u) || 0;
              const share = Math.floor((uUsage / totalUsage) * totalC);
              return [u, uUsage, share];
            });
            let assigned = prelim.reduce((a, [, , c]) => a + c, 0);
            let remainder = totalC - assigned;
            // distribute remaining cents by highest usage first, then by unit order
            prelim.sort((a, b) => b[1] - a[1] || byNumericUnitOrder(a[0], b[0]));
            let idx = 0;
            while (remainder > 0) {
              const [u] = prelim[idx % prelim.length];
              perUnit[u][cat.label] += 1;
              remainder--;
              idx++;
            }
            // add base shares after distributing pennies (order doesn't matter for totals)
            prelim.forEach(([u, , c]) => {
              perUnit[u][cat.label] += c;
            });
          }
        } else {
          // flat categories split equally, remainder by sorted unit order
          const baseC = Math.floor(totalC / nUnits);
          let remainder = totalC - baseC * nUnits;
          units.forEach((u, i) => {
            const add = i < remainder ? 1 : 0;
            perUnit[u][cat.label] += baseC + add;
          });
        }
      });

      const rows = units.map((u) => {
        const row = perUnit[u];
        const r = {
          Unit: u,
          Usage: row.usage,
          Water: fromCents(row["Water"]),
          Sewer: fromCents(row["Sewer"]),
          Stormwater: fromCents(row["Stormwater"]),
          "Base Charge": fromCents(row["Base Charge"]),
          "Portland Harbor Superfund": fromCents(row["Portland Harbor Superfund"]),
        };
        r.Total = Number(
          (
            r.Water +
            r.Sewer +
            r.Stormwater +
            r["Base Charge"] +
            r["Portland Harbor Superfund"]
          ).toFixed(2)
        );
        return r;
      });

      const totalsRow = rows.reduce(
        (acc, r) => {
          acc.Usage += r.Usage;
          acc.Water += r.Water;
          acc.Sewer += r.Sewer;
          acc.Stormwater += r.Stormwater;
          acc["Base Charge"] += r["Base Charge"];
          acc["Portland Harbor Superfund"] += r["Portland Harbor Superfund"];
          acc.Total += r.Total;
          return acc;
        },
        {
          Unit: "TOTALS",
          Usage: 0,
          Water: 0,
          Sewer: 0,
          Stormwater: 0,
          "Base Charge": 0,
          "Portland Harbor Superfund": 0,
          Total: 0,
        }
      );
      return { rows, totalsRow, unitToAccount };
    }

    function buildWorkbooks({ bill, alloc, chargeName }) {
      const fmt = (d) => (d ? d.toLocaleDateString() : "");
      const preparedOn = new Date();
      const summaryData = [
        ["Billing Start", fmt(bill.billingStart)],
        ["Billing End", fmt(bill.billingEnd)],
        ["Bill Date", fmt(bill.billDate)],
        ["Due Date", fmt(bill.dueDate)],
        ["Water (usage)", bill.totals.water ?? 0],
        ["Sewer (usage)", bill.totals.sewer ?? 0],
        ["Stormwater (flat)", bill.totals.stormwater ?? 0],
        ["Base (flat)", bill.totals.base ?? 0],
        ["Portland Harbor Superfund (flat)", bill.totals.superfund ?? 0],
        ["Prepared On", preparedOn.toLocaleString()],
        ["Notes", "Usage-based = proportional by unit usage; Flat = equal per unit; Penny reconciliation: usage cats by high‑usage first; flat by unit order."],
      ];
      const allocHeader = [
        "Unit",
        "Usage",
        "Water",
        "Sewer",
        "Stormwater",
        "Base Charge",
        "Portland Harbor Superfund",
        "Total",
      ];

      const importDate = toStartOfNextMonth(bill.billingEnd || bill.billDate || new Date());
      const description = `${bill.billingStart?.toLocaleDateString() || ""} to ${bill.billingEnd?.toLocaleDateString() || ""}`;
      const importHeader = ["account", "charge", "amount", "date", "description"];
      const importRows = alloc.rows.map((r) => [
        alloc.unitToAccount.get(r.Unit) || "",
        chargeName,
        Number(r.Total.toFixed(2)),
        importDate.toISOString().substring(0, 10),
        description,
      ]);

      const wb = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet(summaryData), "Summary");
      XLSX.utils.book_append_sheet(
        wb,
        XLSX.utils.aoa_to_sheet([
          allocHeader,
          ...alloc.rows.map((r) => allocHeader.map((h) => r[h])),
          allocHeader.map((h) => alloc.totalsRow[h] ?? (h === "Unit" ? "TOTALS" : 0)),
        ]),
        "Allocations"
      );
      XLSX.utils.book_append_sheet(wb, XLSX.utils.aoa_to_sheet([["account","charge","amount","date","description"], ...importRows]), "Import");
      const fullXlsx = XLSX.write(wb, { type: "array", bookType: "xlsx" });

      const wbImp = XLSX.utils.book_new();
      XLSX.utils.book_append_sheet(wbImp, XLSX.utils.aoa_to_sheet([["account","charge","amount","date","description"], ...importRows]), "Import");
      const importXlsx = XLSX.write(wbImp, { type: "array", bookType: "xlsx" });

      const csv = Papa.unparse([["account","charge","amount","date","description"], ...importRows]);

      return { fullXlsx, importXlsx, importCsv: csv };
    }

    function setMessage(t) {
      msg.textContent = t || "";
    }
    function clearDownloads() {
      downloads.innerHTML = "";
    }
    function addDownload(label, blob, name) {
      const href = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = href;
      a.download = name;
      a.className = "flex items-center justify-between rounded-2xl border border-zinc-200 bg-white p-4 text-sm shadow-sm hover:shadow";
      a.innerHTML = `<div class="flex items-center gap-3"><span class="text-teal-600">⬇</span><span>${label}</span></div><span class="text-xs text-zinc-400">${name}</span>`;
      downloads.appendChild(a);
    }

    $("process").addEventListener("click", async () => {
      try {
        setMessage("");
        clearDownloads();
        const billFile = $("bill").files[0];
        const usageFile = $("usage").files[0];
        const ownerFile = $("owner").files[0];
        if (!billFile || !usageFile || !ownerFile) {
          setMessage("Please add all three files: Bill PDF, Usage CSV, and Owner Export.");
          return;
        }
        setMessage("Processing…");

        let bill = await parseBillPDF(billFile);

        // === FIX 2: Only flag truly missing fields (undefined), not legit zeros ===
        const missing = [];
        if (bill.billingStart === undefined) missing.push("Billing Start");
        if (bill.billingEnd === undefined) missing.push("Billing End");
        if (bill.billDate === undefined) missing.push("Bill Date");
        if (bill.dueDate === undefined) missing.push("Due Date");

        const cats = bill.totals;
        const missingCats = Object.entries({
          Water: cats.water,
          Sewer: cats.sewer,
          Stormwater: cats.stormwater,
          Base: cats.base,
          Superfund: cats.superfund,
        })
          .filter(([, v]) => v === undefined)
          .map(([k]) => k);

        if (missing.length || missingCats.length)
          setMessage(
            `Missing items: ${[...missing, ...missingCats].join(
              ", "
            )}. You can fill them in the fields above, then click Process again.`
          );

        const val = (id) => (document.getElementById(id)?.value || "").trim();
        const maybeDate = (id, prev) => {
          const v = val(id);
          return v ? new Date(v + 'T00:00:00') : prev;
        };
        const parseMoney = (v) => Number(String(v).replace(/[^\d.-]/g, "")) || 0;
        const maybeMoney = (id, prev) => {
          const v = val(id);
          return v !== "" ? parseMoney(v) : (prev ?? 0);
        };

        bill = {
          ...bill,
          billingStart: maybeDate("fix-billingStart", bill.billingStart),
          billingEnd: maybeDate("fix-billingEnd", bill.billingEnd),
          billDate: maybeDate("fix-billDate", bill.billDate),
          dueDate: maybeDate("fix-dueDate", bill.dueDate),
          totals: {
            water: maybeMoney("fix-water", bill.totals.water),
            sewer: maybeMoney("fix-sewer", bill.totals.sewer),
            stormwater: maybeMoney("fix-stormwater", bill.totals.stormwater),
            base: maybeMoney("fix-base", bill.totals.base),
            superfund: maybeMoney("fix-superfund", bill.totals.superfund),
          },
        };

        const usageRows = parseUsageCSV(await fileToText(usageFile));
        const ownerRows = parseOwnerExport(await fileToText(ownerFile));

        const alloc = allocate(bill, usageRows, ownerRows);
        const chargeName = chargeNameInput.value || "Water Billing";
        const { fullXlsx, importXlsx, importCsv } = buildWorkbooks({ bill, alloc, chargeName });

        addDownload(
          "Download Full Workbook (xlsx)",
          new Blob([fullXlsx], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          }),
          `MicroHOA_Allocation_${Date.now()}.xlsx`
        );
        addDownload(
          "Download Import Only (xlsx)",
          new Blob([importXlsx], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          }),
          `MicroHOA_Import_${Date.now()}.xlsx`
        );
        addDownload(
          "Download Import Only (csv)",
          new Blob([importCsv], {
            type: "text/csv",
          }),
          `MicroHOA_Import_${Date.now()}.csv`
        );

        localStorage.setItem("mh_charge_name", chargeName);
        setMessage("All set! Files are ready below.");
      } catch (e) {
        console.error(e);
        setMessage("Something went wrong. Please check your files and try again.");
      }
    });
  </script>
</body>
</html>
